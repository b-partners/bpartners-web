/* tslint:disable */
/* eslint-disable */
/**
 * BPartners API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: latest
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface Account
 */
export interface Account {
  /**
   *
   * @type {string}
   * @memberof Account
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  iban?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  bic?: string;
  /**
   *
   * @type {number}
   * @memberof Account
   */
  availableBalance?: number;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  IBAN?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  BIC?: string;
}
/**
 *
 * @export
 * @interface AccountHolder
 */
export interface AccountHolder {
  /**
   *
   * @type {string}
   * @memberof AccountHolder
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof AccountHolder
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof AccountHolder
   */
  address?: string;
  /**
   *
   * @type {string}
   * @memberof AccountHolder
   */
  city?: string;
  /**
   *
   * @type {string}
   * @memberof AccountHolder
   */
  country?: string;
  /**
   *
   * @type {string}
   * @memberof AccountHolder
   */
  postalCode?: string;
  /**
   *
   * @type {string}
   * @memberof AccountHolder
   */
  siren?: string;
  /**
   *
   * @type {string}
   * @memberof AccountHolder
   */
  officialActivityName?: string;
  /**
   *
   * @type {ContactAddress}
   * @memberof AccountHolder
   */
  contactAddress?: ContactAddress;
  /**
   *
   * @type {CompanyInfo}
   * @memberof AccountHolder
   */
  companyInfo?: CompanyInfo;
  /**
   *
   * @type {CompanyBusinessActivity}
   * @memberof AccountHolder
   */
  businessActivities?: CompanyBusinessActivity;
  /**
   *
   * @type {VerificationStatus}
   * @memberof AccountHolder
   */
  verificationStatus?: VerificationStatus;
}
/**
 *
 * @export
 * @interface AuthInitiation
 */
export interface AuthInitiation {
  /**
   *
   * @type {string}
   * @memberof AuthInitiation
   */
  state?: string;
  /**
   *
   * @type {string}
   * @memberof AuthInitiation
   */
  phone?: string;
  /**
   *
   * @type {RedirectionStatusUrls}
   * @memberof AuthInitiation
   */
  redirectionStatusUrls?: RedirectionStatusUrls;
}
/**
 *
 * @export
 * @interface BadRequestException
 */
export interface BadRequestException {
  /**
   *
   * @type {string}
   * @memberof BadRequestException
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof BadRequestException
   */
  message?: string;
}
/**
 *
 * @export
 * @interface BusinessActivity
 */
export interface BusinessActivity {
  /**
   *
   * @type {string}
   * @memberof BusinessActivity
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof BusinessActivity
   */
  name?: string;
}
/**
 *
 * @export
 * @interface CompanyBusinessActivity
 */
export interface CompanyBusinessActivity {
  /**
   *
   * @type {string}
   * @memberof CompanyBusinessActivity
   */
  primary?: string;
  /**
   *
   * @type {string}
   * @memberof CompanyBusinessActivity
   */
  secondary?: string;
}
/**
 *
 * @export
 * @interface CompanyInfo
 */
export interface CompanyInfo {
  /**
   *
   * @type {string}
   * @memberof CompanyInfo
   */
  phone?: string;
  /**
   *
   * @type {string}
   * @memberof CompanyInfo
   */
  email?: string;
  /**
   *
   * @type {number}
   * @memberof CompanyInfo
   */
  socialCapital?: number;
  /**
   *
   * @type {string}
   * @memberof CompanyInfo
   */
  tvaNumber?: string;
}
/**
 *
 * @export
 * @interface ContactAddress
 */
export interface ContactAddress {
  /**
   *
   * @type {string}
   * @memberof ContactAddress
   */
  address?: string;
  /**
   *
   * @type {string}
   * @memberof ContactAddress
   */
  city?: string;
  /**
   *
   * @type {string}
   * @memberof ContactAddress
   */
  country?: string;
  /**
   *
   * @type {string}
   * @memberof ContactAddress
   */
  postalCode?: string;
}
/**
 *
 * @export
 * @interface CreateCustomer
 */
export interface CreateCustomer {
  /**
   *
   * @type {string}
   * @memberof CreateCustomer
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof CreateCustomer
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof CreateCustomer
   */
  phone?: string;
  /**
   *
   * @type {string}
   * @memberof CreateCustomer
   */
  website?: string;
  /**
   *
   * @type {string}
   * @memberof CreateCustomer
   */
  address?: string;
  /**
   *
   * @type {number}
   * @memberof CreateCustomer
   */
  zipCode?: number;
  /**
   *
   * @type {string}
   * @memberof CreateCustomer
   */
  city?: string;
  /**
   *
   * @type {string}
   * @memberof CreateCustomer
   */
  country?: string;
}
/**
 *
 * @export
 * @interface CreateInvoiceRelaunch
 */
export interface CreateInvoiceRelaunch {
  /**
   *
   * @type {string}
   * @memberof CreateInvoiceRelaunch
   */
  subject?: string;
  /**
   *
   * @type {string}
   * @memberof CreateInvoiceRelaunch
   */
  message?: string;
}
/**
 *
 * @export
 * @interface CreateInvoiceRelaunchConf
 */
export interface CreateInvoiceRelaunchConf {
  /**
   * The frequency of sending the message in days
   * @type {number}
   * @memberof CreateInvoiceRelaunchConf
   */
  unpaidRelaunch?: number;
  /**
   * The frequency of sending the message in days
   * @type {number}
   * @memberof CreateInvoiceRelaunchConf
   */
  draftRelaunch?: number;
}
/**
 *
 * @export
 * @interface CreatePreUser
 */
export interface CreatePreUser {
  /**
   *
   * @type {string}
   * @memberof CreatePreUser
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof CreatePreUser
   */
  lastName?: string;
  /**
   *
   * @type {string}
   * @memberof CreatePreUser
   */
  society?: string;
  /**
   *
   * @type {string}
   * @memberof CreatePreUser
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof CreatePreUser
   */
  phone?: string;
}
/**
 *
 * @export
 * @interface CreateProduct
 */
export interface CreateProduct {
  /**
   *
   * @type {string}
   * @memberof CreateProduct
   */
  description?: string;
  /**
   *
   * @type {number}
   * @memberof CreateProduct
   */
  quantity?: number;
  /**
   *
   * @type {number}
   * @memberof CreateProduct
   */
  unitPrice?: number;
  /**
   *
   * @type {number}
   * @memberof CreateProduct
   */
  vatPercent?: number;
}
/**
 *
 * @export
 * @interface CreateToken
 */
export interface CreateToken {
  /**
   *
   * @type {string}
   * @memberof CreateToken
   */
  code?: string;
  /**
   *
   * @type {RedirectionStatusUrls}
   * @memberof CreateToken
   */
  redirectionStatusUrls?: RedirectionStatusUrls;
}
/**
 *
 * @export
 * @interface CreateTransactionCategory
 */
export interface CreateTransactionCategory {
  /**
   *
   * @type {string}
   * @memberof CreateTransactionCategory
   */
  type?: string;
  /**
   *
   * @type {number}
   * @memberof CreateTransactionCategory
   */
  vat?: number;
}
/**
 *
 * @export
 * @interface CrupdateInvoice
 */
export interface CrupdateInvoice {
  /**
   *
   * @type {Array<CreateProduct>}
   * @memberof CrupdateInvoice
   */
  products?: Array<CreateProduct>;
  /**
   *
   * @type {string}
   * @memberof CrupdateInvoice
   */
  ref?: string;
  /**
   *
   * @type {string}
   * @memberof CrupdateInvoice
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof CrupdateInvoice
   */
  comment?: string;
  /**
   *
   * @type {Customer}
   * @memberof CrupdateInvoice
   */
  customer?: Customer;
  /**
   *
   * @type {InvoiceStatus}
   * @memberof CrupdateInvoice
   */
  status?: InvoiceStatus;
  /**
   *
   * @type {string}
   * @memberof CrupdateInvoice
   */
  sendingDate?: string;
  /**
   *
   * @type {string}
   * @memberof CrupdateInvoice
   */
  toPayAt?: string;
}
/**
 *
 * @export
 * @interface CrupdateInvoiceTemplate
 */
export interface CrupdateInvoiceTemplate {
  /**
   *
   * @type {string}
   * @memberof CrupdateInvoiceTemplate
   */
  ref?: string;
  /**
   *
   * @type {string}
   * @memberof CrupdateInvoiceTemplate
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof CrupdateInvoiceTemplate
   */
  comment?: string;
  /**
   *
   * @type {Customer}
   * @memberof CrupdateInvoiceTemplate
   */
  customer?: Customer;
  /**
   *
   * @type {InvoiceStatus}
   * @memberof CrupdateInvoiceTemplate
   */
  status?: InvoiceStatus;
  /**
   *
   * @type {string}
   * @memberof CrupdateInvoiceTemplate
   */
  sendingDate?: string;
  /**
   *
   * @type {string}
   * @memberof CrupdateInvoiceTemplate
   */
  toPayAt?: string;
}
/**
 *
 * @export
 * @interface Customer
 */
export interface Customer {
  /**
   *
   * @type {string}
   * @memberof Customer
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Customer
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Customer
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof Customer
   */
  phone?: string;
  /**
   *
   * @type {string}
   * @memberof Customer
   */
  website?: string;
  /**
   *
   * @type {string}
   * @memberof Customer
   */
  address?: string;
  /**
   *
   * @type {number}
   * @memberof Customer
   */
  zipCode?: number;
  /**
   *
   * @type {string}
   * @memberof Customer
   */
  city?: string;
  /**
   *
   * @type {string}
   * @memberof Customer
   */
  country?: string;
}
/**
 *
 * @export
 * @enum {string}
 */

export enum EnableStatus {
  Enabled = 'ENABLED',
  Disabled = 'DISABLED',
}

/**
 *
 * @export
 * @interface Exception
 */
export interface Exception {
  /**
   *
   * @type {string}
   * @memberof Exception
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof Exception
   */
  message?: string;
}
/**
 *
 * @export
 * @interface FileInfo
 */
export interface FileInfo {
  /**
   *
   * @type {string}
   * @memberof FileInfo
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof FileInfo
   */
  uploadedAt?: string;
  /**
   *
   * @type {string}
   * @memberof FileInfo
   */
  uploadedByAccountId?: string;
  /**
   *
   * @type {number}
   * @memberof FileInfo
   */
  sizeInKB?: number;
  /**
   *
   * @type {string}
   * @memberof FileInfo
   */
  sha256?: string;
}
/**
 *
 * @export
 * @enum {string}
 */

export enum FileType {
  Invoice = 'INVOICE',
  Logo = 'LOGO',
}

/**
 *
 * @export
 * @interface InternalServerException
 */
export interface InternalServerException {
  /**
   *
   * @type {string}
   * @memberof InternalServerException
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof InternalServerException
   */
  message?: string;
}
/**
 *
 * @export
 * @interface Invoice
 */
export interface Invoice {
  /**
   *
   * @type {string}
   * @memberof Invoice
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Invoice
   */
  paymentUrl?: string;
  /**
   *
   * @type {Array<Product>}
   * @memberof Invoice
   */
  products?: Array<Product>;
  /**
   *
   * @type {number}
   * @memberof Invoice
   */
  totalVat?: number;
  /**
   *
   * @type {number}
   * @memberof Invoice
   */
  totalPriceWithoutVat?: number;
  /**
   *
   * @type {number}
   * @memberof Invoice
   */
  totalPriceWithVat?: number;
  /**
   *
   * @type {InvoiceStatus}
   * @memberof Invoice
   */
  status?: InvoiceStatus;
  /**
   *
   * @type {string}
   * @memberof Invoice
   */
  updatedAt?: string;
  /**
   * Identifier of the PDF file that is automatically generated for each crupdate. Its value is `null` when generation is not finished yet.
   * @type {string}
   * @memberof Invoice
   */
  fileId?: string;
  /**
   *
   * @type {string}
   * @memberof Invoice
   */
  ref?: string;
  /**
   *
   * @type {string}
   * @memberof Invoice
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof Invoice
   */
  comment?: string;
  /**
   *
   * @type {Customer}
   * @memberof Invoice
   */
  customer?: Customer;
  /**
   *
   * @type {string}
   * @memberof Invoice
   */
  sendingDate?: string;
  /**
   *
   * @type {string}
   * @memberof Invoice
   */
  toPayAt?: string;
}
/**
 *
 * @export
 * @interface InvoiceRelaunch
 */
export interface InvoiceRelaunch {
  /**
   *
   * @type {string}
   * @memberof InvoiceRelaunch
   */
  id?: string;
  /**
   *
   * @type {RelaunchType}
   * @memberof InvoiceRelaunch
   */
  type?: RelaunchType;
  /**
   *
   * @type {Invoice}
   * @memberof InvoiceRelaunch
   */
  invoice?: Invoice;
  /**
   *
   * @type {string}
   * @memberof InvoiceRelaunch
   */
  accountId?: string;
  /**
   *
   * @type {boolean}
   * @memberof InvoiceRelaunch
   */
  isUserRelaunched?: boolean;
  /**
   *
   * @type {string}
   * @memberof InvoiceRelaunch
   */
  creationDatetime?: string;
}
/**
 *
 * @export
 * @interface InvoiceRelaunchConf
 */
export interface InvoiceRelaunchConf {
  /**
   *
   * @type {string}
   * @memberof InvoiceRelaunchConf
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceRelaunchConf
   */
  updatedAt?: string;
  /**
   * The frequency of sending the message in days
   * @type {number}
   * @memberof InvoiceRelaunchConf
   */
  unpaidRelaunch?: number;
  /**
   * The frequency of sending the message in days
   * @type {number}
   * @memberof InvoiceRelaunchConf
   */
  draftRelaunch?: number;
}
/**
 *
 * @export
 * @enum {string}
 */

export enum InvoiceStatus {
  Draft = 'DRAFT',
  Accepted = 'ACCEPTED',
  Proposal = 'PROPOSAL',
  Confirmed = 'CONFIRMED',
  Paid = 'PAID',
}

/**
 *
 * @export
 * @interface LegalFile
 */
export interface LegalFile {
  /**
   *
   * @type {string}
   * @memberof LegalFile
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof LegalFile
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof LegalFile
   */
  fileUrl?: string;
  /**
   *
   * @type {string}
   * @memberof LegalFile
   */
  approvalDatetime?: string;
}
/**
 *
 * @export
 * @interface Marketplace
 */
export interface Marketplace {
  /**
   *
   * @type {string}
   * @memberof Marketplace
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Marketplace
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Marketplace
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof Marketplace
   */
  phoneNumber?: string;
  /**
   *
   * @type {string}
   * @memberof Marketplace
   */
  websiteUrl?: string;
  /**
   *
   * @type {string}
   * @memberof Marketplace
   */
  logoUrl?: string;
}
/**
 *
 * @export
 * @interface MonthlyTransactionsSummary
 */
export interface MonthlyTransactionsSummary {
  /**
   *
   * @type {string}
   * @memberof MonthlyTransactionsSummary
   */
  id?: string;
  /**
   * Months are represented by numbers from 0 to 11 respectively. For example, January  (0), etc.
   * @type {number}
   * @memberof MonthlyTransactionsSummary
   */
  month?: number;
  /**
   * Format is cents
   * @type {number}
   * @memberof MonthlyTransactionsSummary
   */
  income?: number;
  /**
   * Format is cents
   * @type {number}
   * @memberof MonthlyTransactionsSummary
   */
  outcome?: number;
  /**
   * Format is cents
   * @type {number}
   * @memberof MonthlyTransactionsSummary
   */
  cashFlow?: number;
  /**
   * Note that the summary is updated every hour
   * @type {string}
   * @memberof MonthlyTransactionsSummary
   */
  updatedAt?: string;
}
/**
 *
 * @export
 * @interface NotAuthorizedException
 */
export interface NotAuthorizedException {
  /**
   *
   * @type {string}
   * @memberof NotAuthorizedException
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof NotAuthorizedException
   */
  message?: string;
}
/**
 *
 * @export
 * @interface OnboardingInitiation
 */
export interface OnboardingInitiation {
  /**
   *
   * @type {RedirectionStatusUrls}
   * @memberof OnboardingInitiation
   */
  redirectionStatusUrls?: RedirectionStatusUrls;
}
/**
 *
 * @export
 * @interface PaymentInitiation
 */
export interface PaymentInitiation {
  /**
   *
   * @type {string}
   * @memberof PaymentInitiation
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentInitiation
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentInitiation
   */
  reference?: string;
  /**
   *
   * @type {number}
   * @memberof PaymentInitiation
   */
  amount?: number;
  /**
   *
   * @type {string}
   * @memberof PaymentInitiation
   */
  payerName?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentInitiation
   */
  payerEmail?: string;
  /**
   *
   * @type {RedirectionStatusUrls}
   * @memberof PaymentInitiation
   */
  redirectionStatusUrls?: RedirectionStatusUrls;
}
/**
 *
 * @export
 * @interface PaymentRedirection
 */
export interface PaymentRedirection {
  /**
   *
   * @type {string}
   * @memberof PaymentRedirection
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentRedirection
   */
  redirectionUrl?: string;
  /**
   *
   * @type {RedirectionStatusUrls}
   * @memberof PaymentRedirection
   */
  redirectionStatusUrls?: RedirectionStatusUrls;
}
/**
 *
 * @export
 * @interface PreUser
 */
export interface PreUser {
  /**
   *
   * @type {string}
   * @memberof PreUser
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof PreUser
   */
  entranceDatetime?: string;
  /**
   *
   * @type {string}
   * @memberof PreUser
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof PreUser
   */
  lastName?: string;
  /**
   *
   * @type {string}
   * @memberof PreUser
   */
  society?: string;
  /**
   *
   * @type {string}
   * @memberof PreUser
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof PreUser
   */
  phone?: string;
}
/**
 *
 * @export
 * @interface Product
 */
export interface Product {
  /**
   *
   * @type {string}
   * @memberof Product
   */
  id?: string;
  /**
   *
   * @type {number}
   * @memberof Product
   */
  totalVat?: number;
  /**
   *
   * @type {number}
   * @memberof Product
   */
  totalPriceWithVat?: number;
  /**
   *
   * @type {string}
   * @memberof Product
   */
  description?: string;
  /**
   *
   * @type {number}
   * @memberof Product
   */
  quantity?: number;
  /**
   *
   * @type {number}
   * @memberof Product
   */
  unitPrice?: number;
  /**
   *
   * @type {number}
   * @memberof Product
   */
  vatPercent?: number;
}
/**
 *
 * @export
 * @interface Redirection
 */
export interface Redirection {
  /**
   *
   * @type {string}
   * @memberof Redirection
   */
  redirectionUrl?: string;
  /**
   *
   * @type {RedirectionStatusUrls}
   * @memberof Redirection
   */
  redirectionStatusUrls?: RedirectionStatusUrls;
}
/**
 *
 * @export
 * @interface Redirection1
 */
export interface Redirection1 {
  /**
   *
   * @type {string}
   * @memberof Redirection1
   */
  redirectionUrl?: string;
  /**
   *
   * @type {RedirectionStatusUrls}
   * @memberof Redirection1
   */
  redirectionStatusUrls?: RedirectionStatusUrls;
}
/**
 *
 * @export
 * @interface RedirectionStatusUrls
 */
export interface RedirectionStatusUrls {
  /**
   *
   * @type {string}
   * @memberof RedirectionStatusUrls
   */
  successUrl?: string;
  /**
   *
   * @type {string}
   * @memberof RedirectionStatusUrls
   */
  failureUrl?: string;
}
/**
 *
 * @export
 * @enum {string}
 */

export enum RelaunchType {
  Proposal = 'PROPOSAL',
  Confirmed = 'CONFIRMED',
}

/**
 *
 * @export
 * @interface ResourceNotFoundException
 */
export interface ResourceNotFoundException {
  /**
   *
   * @type {string}
   * @memberof ResourceNotFoundException
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof ResourceNotFoundException
   */
  message?: string;
}
/**
 *
 * @export
 * @interface Token
 */
export interface Token {
  /**
   *
   * @type {string}
   * @memberof Token
   */
  accessToken?: string;
  /**
   *
   * @type {string}
   * @memberof Token
   */
  refreshToken?: string;
  /**
   *
   * @type {number}
   * @memberof Token
   */
  expiresIn?: number;
  /**
   *
   * @type {Whoami}
   * @memberof Token
   */
  whoami?: Whoami;
}
/**
 *
 * @export
 * @interface TooManyRequestsException
 */
export interface TooManyRequestsException {
  /**
   *
   * @type {string}
   * @memberof TooManyRequestsException
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof TooManyRequestsException
   */
  message?: string;
}
/**
 *
 * @export
 * @interface Transaction
 */
export interface Transaction {
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  id?: string;
  /**
   *
   * @type {number}
   * @memberof Transaction
   */
  amount?: number;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  reference?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  paymentDatetime?: string;
  /**
   *
   * @type {Array<TransactionCategory>}
   * @memberof Transaction
   */
  category?: Array<TransactionCategory>;
  /**
   *
   * @type {TransactionTypeEnum}
   * @memberof Transaction
   */
  type?: TransactionTypeEnum;
  /**
   *
   * @type {TransactionStatus}
   * @memberof Transaction
   */
  status?: TransactionStatus;
}
/**
 *
 * @export
 * @interface TransactionCategory
 */
export interface TransactionCategory {
  /**
   *
   * @type {string}
   * @memberof TransactionCategory
   */
  id?: string;
  /**
   *
   * @type {boolean}
   * @memberof TransactionCategory
   */
  userDefined?: boolean;
  /**
   *
   * @type {number}
   * @memberof TransactionCategory
   */
  count?: number;
  /**
   *
   * @type {TransactionTypeEnum}
   * @memberof TransactionCategory
   */
  transactionType?: TransactionTypeEnum;
  /**
   *
   * @type {string}
   * @memberof TransactionCategory
   */
  type?: string;
  /**
   *
   * @type {number}
   * @memberof TransactionCategory
   */
  vat?: number;
}
/**
 *
 * @export
 * @enum {string}
 */

export enum TransactionStatus {
  Pending = 'PENDING',
  Booked = 'BOOKED',
}

/**
 *
 * @export
 * @enum {string}
 */

export enum TransactionTypeEnum {
  Income = 'INCOME',
  Outcome = 'OUTCOME',
}

/**
 *
 * @export
 * @interface TransactionsSummary
 */
export interface TransactionsSummary {
  /**
   *
   * @type {number}
   * @memberof TransactionsSummary
   */
  year?: number;
  /**
   *
   * @type {Array<MonthlyTransactionsSummary>}
   * @memberof TransactionsSummary
   */
  summary?: Array<MonthlyTransactionsSummary>;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  lastName?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  birthDate?: string;
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  idVerified?: boolean;
  /**
   *
   * @type {string}
   * @memberof User
   */
  identificationStatus?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  nationalityCCA3?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  phone?: string;
  /**
   *
   * @type {number}
   * @memberof User
   */
  monthlySubscriptionAmount?: number;
  /**
   *
   * @type {string}
   * @memberof User
   */
  logoFileId?: string;
  /**
   *
   * @type {EnableStatus}
   * @memberof User
   */
  status?: EnableStatus;
}
/**
 *
 * @export
 * @enum {string}
 */

export enum VerificationStatus {
  Verified = 'VERIFIED',
  NotStarted = 'NOT_STARTED',
  Pending = 'PENDING',
  WaitingForInformation = 'WAITING_FOR_INFORMATION',
}

/**
 *
 * @export
 * @interface Whoami
 */
export interface Whoami {
  /**
   *
   * @type {User}
   * @memberof Whoami
   */
  user?: User;
}

/**
 * CustomersApi - axios parameter creator
 * @export
 */
export const CustomersApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create customers for an account
     * @param {string} id
     * @param {Array<CreateCustomer>} [createCustomer]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCustomers: async (id: string, createCustomer?: Array<CreateCustomer>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('createCustomers', 'id', id);
      const localVarPath = `/accounts/{id}/customers`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(createCustomer, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get customers of an account
     * @param {string} id
     * @param {string} [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCustomers: async (id: string, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getCustomers', 'id', id);
      const localVarPath = `/accounts/{id}/customers`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (name !== undefined) {
        localVarQueryParameter['name'] = name;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CustomersApi - functional programming interface
 * @export
 */
export const CustomersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CustomersApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create customers for an account
     * @param {string} id
     * @param {Array<CreateCustomer>} [createCustomer]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createCustomers(
      id: string,
      createCustomer?: Array<CreateCustomer>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Customer>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomers(id, createCustomer, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get customers of an account
     * @param {string} id
     * @param {string} [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCustomers(
      id: string,
      name?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Customer>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomers(id, name, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * CustomersApi - factory interface
 * @export
 */
export const CustomersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = CustomersApiFp(configuration);
  return {
    /**
     *
     * @summary Create customers for an account
     * @param {string} id
     * @param {Array<CreateCustomer>} [createCustomer]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCustomers(id: string, createCustomer?: Array<CreateCustomer>, options?: any): AxiosPromise<Array<Customer>> {
      return localVarFp.createCustomers(id, createCustomer, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get customers of an account
     * @param {string} id
     * @param {string} [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCustomers(id: string, name?: string, options?: any): AxiosPromise<Array<Customer>> {
      return localVarFp.getCustomers(id, name, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * CustomersApi - object-oriented interface
 * @export
 * @class CustomersApi
 * @extends {BaseAPI}
 */
export class CustomersApi extends BaseAPI {
  /**
   *
   * @summary Create customers for an account
   * @param {string} id
   * @param {Array<CreateCustomer>} [createCustomer]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public createCustomers(id: string, createCustomer?: Array<CreateCustomer>, options?: AxiosRequestConfig) {
    return CustomersApiFp(this.configuration)
      .createCustomers(id, createCustomer, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get customers of an account
   * @param {string} id
   * @param {string} [name]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public getCustomers(id: string, name?: string, options?: AxiosRequestConfig) {
    return CustomersApiFp(this.configuration)
      .getCustomers(id, name, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Download a file
     * @param {string} aId
     * @param {string} id
     * @param {string} [accessToken]
     * @param {FileType} [fileType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFile: async (aId: string, id: string, accessToken?: string, fileType?: FileType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'aId' is not null or undefined
      assertParamExists('downloadFile', 'aId', aId);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('downloadFile', 'id', id);
      const localVarPath = `/accounts/{aId}/files/{id}/raw`
        .replace(`{${'aId'}}`, encodeURIComponent(String(aId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (accessToken !== undefined) {
        localVarQueryParameter['accessToken'] = accessToken;
      }

      if (fileType !== undefined) {
        localVarQueryParameter['fileType'] = fileType;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get information of a file
     * @param {string} aId
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileById: async (aId: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'aId' is not null or undefined
      assertParamExists('getFileById', 'aId', aId);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getFileById', 'id', id);
      const localVarPath = `/accounts/{aId}/files/{id}`
        .replace(`{${'aId'}}`, encodeURIComponent(String(aId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Upload a file. Fails if file already exists.
     * @param {string} aId
     * @param {string} id
     * @param {any} body
     * @param {string} [fileType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFile: async (aId: string, id: string, body: any, fileType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'aId' is not null or undefined
      assertParamExists('uploadFile', 'aId', aId);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('uploadFile', 'id', id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('uploadFile', 'body', body);
      const localVarPath = `/accounts/{aId}/files/{id}/raw`
        .replace(`{${'aId'}}`, encodeURIComponent(String(aId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (fileType !== undefined) {
        localVarQueryParameter['fileType'] = fileType;
      }

      localVarHeaderParameter['Content-Type'] = 'image/jpeg';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Download a file
     * @param {string} aId
     * @param {string} id
     * @param {string} [accessToken]
     * @param {FileType} [fileType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadFile(
      aId: string,
      id: string,
      accessToken?: string,
      fileType?: FileType,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFile(aId, id, accessToken, fileType, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get information of a file
     * @param {string} aId
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFileById(aId: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFileById(aId, id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Upload a file. Fails if file already exists.
     * @param {string} aId
     * @param {string} id
     * @param {any} body
     * @param {string} [fileType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadFile(
      aId: string,
      id: string,
      body: any,
      fileType?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(aId, id, body, fileType, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = FilesApiFp(configuration);
  return {
    /**
     *
     * @summary Download a file
     * @param {string} aId
     * @param {string} id
     * @param {string} [accessToken]
     * @param {FileType} [fileType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFile(aId: string, id: string, accessToken?: string, fileType?: FileType, options?: any): AxiosPromise<any> {
      return localVarFp.downloadFile(aId, id, accessToken, fileType, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get information of a file
     * @param {string} aId
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileById(aId: string, id: string, options?: any): AxiosPromise<FileInfo> {
      return localVarFp.getFileById(aId, id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Upload a file. Fails if file already exists.
     * @param {string} aId
     * @param {string} id
     * @param {any} body
     * @param {string} [fileType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFile(aId: string, id: string, body: any, fileType?: string, options?: any): AxiosPromise<any> {
      return localVarFp.uploadFile(aId, id, body, fileType, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
  /**
   *
   * @summary Download a file
   * @param {string} aId
   * @param {string} id
   * @param {string} [accessToken]
   * @param {FileType} [fileType]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public downloadFile(aId: string, id: string, accessToken?: string, fileType?: FileType, options?: AxiosRequestConfig) {
    return FilesApiFp(this.configuration)
      .downloadFile(aId, id, accessToken, fileType, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get information of a file
   * @param {string} aId
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public getFileById(aId: string, id: string, options?: AxiosRequestConfig) {
    return FilesApiFp(this.configuration)
      .getFileById(aId, id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Upload a file. Fails if file already exists.
   * @param {string} aId
   * @param {string} id
   * @param {any} body
   * @param {string} [fileType]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public uploadFile(aId: string, id: string, body: any, fileType?: string, options?: AxiosRequestConfig) {
    return FilesApiFp(this.configuration)
      .uploadFile(aId, id, body, fileType, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * OnboardingApi - axios parameter creator
 * @export
 */
export const OnboardingApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Pre-onboard users
     * @param {Array<CreatePreUser>} createPreUser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPreUsers: async (createPreUser: Array<CreatePreUser>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createPreUser' is not null or undefined
      assertParamExists('createPreUsers', 'createPreUser', createPreUser);
      const localVarPath = `/preUsers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(createPreUser, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Initiate an onboarding process
     * @param {OnboardingInitiation} onboardingInitiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initiateOnboarding: async (onboardingInitiation: OnboardingInitiation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'onboardingInitiation' is not null or undefined
      assertParamExists('initiateOnboarding', 'onboardingInitiation', onboardingInitiation);
      const localVarPath = `/onboardingInitiation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(onboardingInitiation, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OnboardingApi - functional programming interface
 * @export
 */
export const OnboardingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = OnboardingApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Pre-onboard users
     * @param {Array<CreatePreUser>} createPreUser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPreUsers(
      createPreUser: Array<CreatePreUser>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PreUser>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPreUsers(createPreUser, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Initiate an onboarding process
     * @param {OnboardingInitiation} onboardingInitiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async initiateOnboarding(
      onboardingInitiation: OnboardingInitiation,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Redirection1>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.initiateOnboarding(onboardingInitiation, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * OnboardingApi - factory interface
 * @export
 */
export const OnboardingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = OnboardingApiFp(configuration);
  return {
    /**
     *
     * @summary Pre-onboard users
     * @param {Array<CreatePreUser>} createPreUser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPreUsers(createPreUser: Array<CreatePreUser>, options?: any): AxiosPromise<Array<PreUser>> {
      return localVarFp.createPreUsers(createPreUser, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Initiate an onboarding process
     * @param {OnboardingInitiation} onboardingInitiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initiateOnboarding(onboardingInitiation: OnboardingInitiation, options?: any): AxiosPromise<Redirection1> {
      return localVarFp.initiateOnboarding(onboardingInitiation, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * OnboardingApi - object-oriented interface
 * @export
 * @class OnboardingApi
 * @extends {BaseAPI}
 */
export class OnboardingApi extends BaseAPI {
  /**
   *
   * @summary Pre-onboard users
   * @param {Array<CreatePreUser>} createPreUser
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OnboardingApi
   */
  public createPreUsers(createPreUser: Array<CreatePreUser>, options?: AxiosRequestConfig) {
    return OnboardingApiFp(this.configuration)
      .createPreUsers(createPreUser, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Initiate an onboarding process
   * @param {OnboardingInitiation} onboardingInitiation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OnboardingApi
   */
  public initiateOnboarding(onboardingInitiation: OnboardingInitiation, options?: AxiosRequestConfig) {
    return OnboardingApiFp(this.configuration)
      .initiateOnboarding(onboardingInitiation, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * PayingApi - axios parameter creator
 * @export
 */
export const PayingApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Configure the automatic relaunch of all invoices of an account
     * @param {string} aId Account identifier
     * @param {CreateInvoiceRelaunchConf} createInvoiceRelaunchConf
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    configureRelaunch: async (aId: string, createInvoiceRelaunchConf: CreateInvoiceRelaunchConf, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'aId' is not null or undefined
      assertParamExists('configureRelaunch', 'aId', aId);
      // verify required parameter 'createInvoiceRelaunchConf' is not null or undefined
      assertParamExists('configureRelaunch', 'createInvoiceRelaunchConf', createInvoiceRelaunchConf);
      const localVarPath = `/accounts/{aId}/invoiceRelaunchConf`.replace(`{${'aId'}}`, encodeURIComponent(String(aId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(createInvoiceRelaunchConf, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create products of an invoice
     * @param {string} aId Account identifier
     * @param {string} iId Invoice identifier
     * @param {Array<CreateProduct>} createProduct
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProducts: async (aId: string, iId: string, createProduct: Array<CreateProduct>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'aId' is not null or undefined
      assertParamExists('createProducts', 'aId', aId);
      // verify required parameter 'iId' is not null or undefined
      assertParamExists('createProducts', 'iId', iId);
      // verify required parameter 'createProduct' is not null or undefined
      assertParamExists('createProducts', 'createProduct', createProduct);
      const localVarPath = `/accounts/{aId}/invoices/{iId}/products`
        .replace(`{${'aId'}}`, encodeURIComponent(String(aId)))
        .replace(`{${'iId'}}`, encodeURIComponent(String(iId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(createProduct, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create transaction categories
     * @param {string} aId Account identifier
     * @param {string} tId Transaction identifier
     * @param {Array<CreateTransactionCategory>} [createTransactionCategory]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransactionCategories: async (
      aId: string,
      tId: string,
      createTransactionCategory?: Array<CreateTransactionCategory>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'aId' is not null or undefined
      assertParamExists('createTransactionCategories', 'aId', aId);
      // verify required parameter 'tId' is not null or undefined
      assertParamExists('createTransactionCategories', 'tId', tId);
      const localVarPath = `/accounts/{aId}/transactions/{tId}/transactionCategories`
        .replace(`{${'aId'}}`, encodeURIComponent(String(aId)))
        .replace(`{${'tId'}}`, encodeURIComponent(String(tId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(createTransactionCategory, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Crupdate an invoice
     * @param {string} aId Account identifier
     * @param {string} iId Invoice identifier
     * @param {CrupdateInvoice} crupdateInvoice
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateInvoice: async (aId: string, iId: string, crupdateInvoice: CrupdateInvoice, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'aId' is not null or undefined
      assertParamExists('crupdateInvoice', 'aId', aId);
      // verify required parameter 'iId' is not null or undefined
      assertParamExists('crupdateInvoice', 'iId', iId);
      // verify required parameter 'crupdateInvoice' is not null or undefined
      assertParamExists('crupdateInvoice', 'crupdateInvoice', crupdateInvoice);
      const localVarPath = `/accounts/{aId}/invoices/{iId}`
        .replace(`{${'aId'}}`, encodeURIComponent(String(aId)))
        .replace(`{${'iId'}}`, encodeURIComponent(String(iId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(crupdateInvoice, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get an invoice
     * @param {string} aId Account identifier
     * @param {string} iId Invoice identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInvoiceById: async (aId: string, iId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'aId' is not null or undefined
      assertParamExists('getInvoiceById', 'aId', aId);
      // verify required parameter 'iId' is not null or undefined
      assertParamExists('getInvoiceById', 'iId', iId);
      const localVarPath = `/accounts/{aId}/invoices/{iId}`
        .replace(`{${'aId'}}`, encodeURIComponent(String(aId)))
        .replace(`{${'iId'}}`, encodeURIComponent(String(iId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the current relaunch configuration for invoice
     * @param {string} aId Account identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInvoiceRelaunchConf: async (aId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'aId' is not null or undefined
      assertParamExists('getInvoiceRelaunchConf', 'aId', aId);
      const localVarPath = `/accounts/{aId}/invoiceRelaunchConf`.replace(`{${'aId'}}`, encodeURIComponent(String(aId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returned invoices are ordered by created datetime desc.
     * @summary Get known invoices of the specified account
     * @param {string} aId
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {InvoiceStatus} [status] Filter invoices by appropriate status. If null, returns all invoices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInvoices: async (aId: string, page?: number, pageSize?: number, status?: InvoiceStatus, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'aId' is not null or undefined
      assertParamExists('getInvoices', 'aId', aId);
      const localVarPath = `/accounts/{aId}/invoices`.replace(`{${'aId'}}`, encodeURIComponent(String(aId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      if (status !== undefined) {
        localVarQueryParameter['status'] = status;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get known products of the specified account
     * @param {string} id
     * @param {boolean} [unique] If description is null, this parameter is required.
     * @param {string} [description] Filter product by description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProducts: async (id: string, unique?: boolean, description?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getProducts', 'id', id);
      const localVarPath = `/accounts/{id}/products`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (unique !== undefined) {
        localVarQueryParameter['unique'] = unique;
      }

      if (description !== undefined) {
        localVarQueryParameter['description'] = description;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get relaunches of a specified invoice
     * @param {string} aId Account identifier
     * @param {string} iId Invoice identifier
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {string} [type] Filter relaunches by type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRelaunches: async (
      aId: string,
      iId: string,
      page?: number,
      pageSize?: number,
      type?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'aId' is not null or undefined
      assertParamExists('getRelaunches', 'aId', aId);
      // verify required parameter 'iId' is not null or undefined
      assertParamExists('getRelaunches', 'iId', iId);
      const localVarPath = `/accounts/{aId}/invoices/{iId}/relaunches`
        .replace(`{${'aId'}}`, encodeURIComponent(String(aId)))
        .replace(`{${'iId'}}`, encodeURIComponent(String(iId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Can be filter by : * unique : show distinct transaction categories * userDefined : show transaction categories defined by the user * date intervals : give the count of transaction categories used by existing transactions  between two dates
     * @summary Get known transaction categories of an account
     * @param {string} aId Account identifier
     * @param {string} from
     * @param {string} to
     * @param {boolean} [userDefined]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactionCategories: async (aId: string, from: string, to: string, userDefined?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'aId' is not null or undefined
      assertParamExists('getTransactionCategories', 'aId', aId);
      // verify required parameter 'from' is not null or undefined
      assertParamExists('getTransactionCategories', 'from', from);
      // verify required parameter 'to' is not null or undefined
      assertParamExists('getTransactionCategories', 'to', to);
      const localVarPath = `/accounts/{aId}/transactionCategories`.replace(`{${'aId'}}`, encodeURIComponent(String(aId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (userDefined !== undefined) {
        localVarQueryParameter['userDefined'] = userDefined;
      }

      if (from !== undefined) {
        localVarQueryParameter['from'] = (from as any) instanceof Date ? (from as any).toISOString().substr(0, 10) : from;
      }

      if (to !== undefined) {
        localVarQueryParameter['to'] = (to as any) instanceof Date ? (to as any).toISOString().substr(0, 10) : to;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get transactions of an account
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactions: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getTransactions', 'id', id);
      const localVarPath = `/accounts/{id}/transactions`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the transactions summary of an account
     * @param {string} aId
     * @param {number} [year] Default value is current year
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactionsSummary: async (aId: string, year?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'aId' is not null or undefined
      assertParamExists('getTransactionsSummary', 'aId', aId);
      const localVarPath = `/accounts/{aId}/transactionsSummary`.replace(`{${'aId'}}`, encodeURIComponent(String(aId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (year !== undefined) {
        localVarQueryParameter['year'] = year;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Initiate payment processes to an account
     * @param {string} id
     * @param {Array<PaymentInitiation>} paymentInitiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initiatePayments: async (id: string, paymentInitiation: Array<PaymentInitiation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('initiatePayments', 'id', id);
      // verify required parameter 'paymentInitiation' is not null or undefined
      assertParamExists('initiatePayments', 'paymentInitiation', paymentInitiation);
      const localVarPath = `/accounts/{id}/paymentInitiations`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(paymentInitiation, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Relaunch an invoice
     * @param {string} aId Account identifier
     * @param {string} iId Invoice identifier
     * @param {CreateInvoiceRelaunch} [createInvoiceRelaunch]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    relaunchInvoice: async (
      aId: string,
      iId: string,
      createInvoiceRelaunch?: CreateInvoiceRelaunch,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'aId' is not null or undefined
      assertParamExists('relaunchInvoice', 'aId', aId);
      // verify required parameter 'iId' is not null or undefined
      assertParamExists('relaunchInvoice', 'iId', iId);
      const localVarPath = `/accounts/{aId}/invoices/{iId}/relaunch`
        .replace(`{${'aId'}}`, encodeURIComponent(String(aId)))
        .replace(`{${'iId'}}`, encodeURIComponent(String(iId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(createInvoiceRelaunch, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PayingApi - functional programming interface
 * @export
 */
export const PayingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PayingApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Configure the automatic relaunch of all invoices of an account
     * @param {string} aId Account identifier
     * @param {CreateInvoiceRelaunchConf} createInvoiceRelaunchConf
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async configureRelaunch(
      aId: string,
      createInvoiceRelaunchConf: CreateInvoiceRelaunchConf,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceRelaunchConf>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.configureRelaunch(aId, createInvoiceRelaunchConf, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Create products of an invoice
     * @param {string} aId Account identifier
     * @param {string} iId Invoice identifier
     * @param {Array<CreateProduct>} createProduct
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createProducts(
      aId: string,
      iId: string,
      createProduct: Array<CreateProduct>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createProducts(aId, iId, createProduct, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Create transaction categories
     * @param {string} aId Account identifier
     * @param {string} tId Transaction identifier
     * @param {Array<CreateTransactionCategory>} [createTransactionCategory]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createTransactionCategories(
      aId: string,
      tId: string,
      createTransactionCategory?: Array<CreateTransactionCategory>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransactionCategory>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createTransactionCategories(aId, tId, createTransactionCategory, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Crupdate an invoice
     * @param {string} aId Account identifier
     * @param {string} iId Invoice identifier
     * @param {CrupdateInvoice} crupdateInvoice
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateInvoice(
      aId: string,
      iId: string,
      crupdateInvoice: CrupdateInvoice,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateInvoice(aId, iId, crupdateInvoice, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get an invoice
     * @param {string} aId Account identifier
     * @param {string} iId Invoice identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInvoiceById(aId: string, iId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoiceById(aId, iId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get the current relaunch configuration for invoice
     * @param {string} aId Account identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInvoiceRelaunchConf(
      aId: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceRelaunchConf>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoiceRelaunchConf(aId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Returned invoices are ordered by created datetime desc.
     * @summary Get known invoices of the specified account
     * @param {string} aId
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {InvoiceStatus} [status] Filter invoices by appropriate status. If null, returns all invoices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInvoices(
      aId: string,
      page?: number,
      pageSize?: number,
      status?: InvoiceStatus,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Invoice>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoices(aId, page, pageSize, status, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get known products of the specified account
     * @param {string} id
     * @param {boolean} [unique] If description is null, this parameter is required.
     * @param {string} [description] Filter product by description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProducts(
      id: string,
      unique?: boolean,
      description?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Product>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getProducts(id, unique, description, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get relaunches of a specified invoice
     * @param {string} aId Account identifier
     * @param {string} iId Invoice identifier
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {string} [type] Filter relaunches by type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRelaunches(
      aId: string,
      iId: string,
      page?: number,
      pageSize?: number,
      type?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InvoiceRelaunch>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRelaunches(aId, iId, page, pageSize, type, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Can be filter by : * unique : show distinct transaction categories * userDefined : show transaction categories defined by the user * date intervals : give the count of transaction categories used by existing transactions  between two dates
     * @summary Get known transaction categories of an account
     * @param {string} aId Account identifier
     * @param {string} from
     * @param {string} to
     * @param {boolean} [userDefined]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTransactionCategories(
      aId: string,
      from: string,
      to: string,
      userDefined?: boolean,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransactionCategory>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionCategories(aId, from, to, userDefined, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get transactions of an account
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTransactions(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Transaction>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactions(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get the transactions summary of an account
     * @param {string} aId
     * @param {number} [year] Default value is current year
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTransactionsSummary(
      aId: string,
      year?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionsSummary>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionsSummary(aId, year, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Initiate payment processes to an account
     * @param {string} id
     * @param {Array<PaymentInitiation>} paymentInitiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async initiatePayments(
      id: string,
      paymentInitiation: Array<PaymentInitiation>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PaymentRedirection>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.initiatePayments(id, paymentInitiation, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Relaunch an invoice
     * @param {string} aId Account identifier
     * @param {string} iId Invoice identifier
     * @param {CreateInvoiceRelaunch} [createInvoiceRelaunch]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async relaunchInvoice(
      aId: string,
      iId: string,
      createInvoiceRelaunch?: CreateInvoiceRelaunch,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceRelaunch>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.relaunchInvoice(aId, iId, createInvoiceRelaunch, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * PayingApi - factory interface
 * @export
 */
export const PayingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = PayingApiFp(configuration);
  return {
    /**
     *
     * @summary Configure the automatic relaunch of all invoices of an account
     * @param {string} aId Account identifier
     * @param {CreateInvoiceRelaunchConf} createInvoiceRelaunchConf
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    configureRelaunch(aId: string, createInvoiceRelaunchConf: CreateInvoiceRelaunchConf, options?: any): AxiosPromise<InvoiceRelaunchConf> {
      return localVarFp.configureRelaunch(aId, createInvoiceRelaunchConf, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Create products of an invoice
     * @param {string} aId Account identifier
     * @param {string} iId Invoice identifier
     * @param {Array<CreateProduct>} createProduct
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProducts(aId: string, iId: string, createProduct: Array<CreateProduct>, options?: any): AxiosPromise<Invoice> {
      return localVarFp.createProducts(aId, iId, createProduct, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Create transaction categories
     * @param {string} aId Account identifier
     * @param {string} tId Transaction identifier
     * @param {Array<CreateTransactionCategory>} [createTransactionCategory]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransactionCategories(
      aId: string,
      tId: string,
      createTransactionCategory?: Array<CreateTransactionCategory>,
      options?: any
    ): AxiosPromise<Array<TransactionCategory>> {
      return localVarFp.createTransactionCategories(aId, tId, createTransactionCategory, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Crupdate an invoice
     * @param {string} aId Account identifier
     * @param {string} iId Invoice identifier
     * @param {CrupdateInvoice} crupdateInvoice
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateInvoice(aId: string, iId: string, crupdateInvoice: CrupdateInvoice, options?: any): AxiosPromise<Invoice> {
      return localVarFp.crupdateInvoice(aId, iId, crupdateInvoice, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get an invoice
     * @param {string} aId Account identifier
     * @param {string} iId Invoice identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInvoiceById(aId: string, iId: string, options?: any): AxiosPromise<Invoice> {
      return localVarFp.getInvoiceById(aId, iId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get the current relaunch configuration for invoice
     * @param {string} aId Account identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInvoiceRelaunchConf(aId: string, options?: any): AxiosPromise<InvoiceRelaunchConf> {
      return localVarFp.getInvoiceRelaunchConf(aId, options).then(request => request(axios, basePath));
    },
    /**
     * Returned invoices are ordered by created datetime desc.
     * @summary Get known invoices of the specified account
     * @param {string} aId
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {InvoiceStatus} [status] Filter invoices by appropriate status. If null, returns all invoices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInvoices(aId: string, page?: number, pageSize?: number, status?: InvoiceStatus, options?: any): AxiosPromise<Array<Invoice>> {
      return localVarFp.getInvoices(aId, page, pageSize, status, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get known products of the specified account
     * @param {string} id
     * @param {boolean} [unique] If description is null, this parameter is required.
     * @param {string} [description] Filter product by description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProducts(id: string, unique?: boolean, description?: string, options?: any): AxiosPromise<Array<Product>> {
      return localVarFp.getProducts(id, unique, description, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get relaunches of a specified invoice
     * @param {string} aId Account identifier
     * @param {string} iId Invoice identifier
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {string} [type] Filter relaunches by type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRelaunches(aId: string, iId: string, page?: number, pageSize?: number, type?: string, options?: any): AxiosPromise<Array<InvoiceRelaunch>> {
      return localVarFp.getRelaunches(aId, iId, page, pageSize, type, options).then(request => request(axios, basePath));
    },
    /**
     * Can be filter by : * unique : show distinct transaction categories * userDefined : show transaction categories defined by the user * date intervals : give the count of transaction categories used by existing transactions  between two dates
     * @summary Get known transaction categories of an account
     * @param {string} aId Account identifier
     * @param {string} from
     * @param {string} to
     * @param {boolean} [userDefined]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactionCategories(aId: string, from: string, to: string, userDefined?: boolean, options?: any): AxiosPromise<Array<TransactionCategory>> {
      return localVarFp.getTransactionCategories(aId, from, to, userDefined, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get transactions of an account
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactions(id: string, options?: any): AxiosPromise<Array<Transaction>> {
      return localVarFp.getTransactions(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get the transactions summary of an account
     * @param {string} aId
     * @param {number} [year] Default value is current year
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactionsSummary(aId: string, year?: number, options?: any): AxiosPromise<TransactionsSummary> {
      return localVarFp.getTransactionsSummary(aId, year, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Initiate payment processes to an account
     * @param {string} id
     * @param {Array<PaymentInitiation>} paymentInitiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initiatePayments(id: string, paymentInitiation: Array<PaymentInitiation>, options?: any): AxiosPromise<Array<PaymentRedirection>> {
      return localVarFp.initiatePayments(id, paymentInitiation, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Relaunch an invoice
     * @param {string} aId Account identifier
     * @param {string} iId Invoice identifier
     * @param {CreateInvoiceRelaunch} [createInvoiceRelaunch]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    relaunchInvoice(aId: string, iId: string, createInvoiceRelaunch?: CreateInvoiceRelaunch, options?: any): AxiosPromise<InvoiceRelaunch> {
      return localVarFp.relaunchInvoice(aId, iId, createInvoiceRelaunch, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * PayingApi - object-oriented interface
 * @export
 * @class PayingApi
 * @extends {BaseAPI}
 */
export class PayingApi extends BaseAPI {
  /**
   *
   * @summary Configure the automatic relaunch of all invoices of an account
   * @param {string} aId Account identifier
   * @param {CreateInvoiceRelaunchConf} createInvoiceRelaunchConf
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PayingApi
   */
  public configureRelaunch(aId: string, createInvoiceRelaunchConf: CreateInvoiceRelaunchConf, options?: AxiosRequestConfig) {
    return PayingApiFp(this.configuration)
      .configureRelaunch(aId, createInvoiceRelaunchConf, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create products of an invoice
   * @param {string} aId Account identifier
   * @param {string} iId Invoice identifier
   * @param {Array<CreateProduct>} createProduct
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PayingApi
   */
  public createProducts(aId: string, iId: string, createProduct: Array<CreateProduct>, options?: AxiosRequestConfig) {
    return PayingApiFp(this.configuration)
      .createProducts(aId, iId, createProduct, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create transaction categories
   * @param {string} aId Account identifier
   * @param {string} tId Transaction identifier
   * @param {Array<CreateTransactionCategory>} [createTransactionCategory]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PayingApi
   */
  public createTransactionCategories(aId: string, tId: string, createTransactionCategory?: Array<CreateTransactionCategory>, options?: AxiosRequestConfig) {
    return PayingApiFp(this.configuration)
      .createTransactionCategories(aId, tId, createTransactionCategory, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Crupdate an invoice
   * @param {string} aId Account identifier
   * @param {string} iId Invoice identifier
   * @param {CrupdateInvoice} crupdateInvoice
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PayingApi
   */
  public crupdateInvoice(aId: string, iId: string, crupdateInvoice: CrupdateInvoice, options?: AxiosRequestConfig) {
    return PayingApiFp(this.configuration)
      .crupdateInvoice(aId, iId, crupdateInvoice, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get an invoice
   * @param {string} aId Account identifier
   * @param {string} iId Invoice identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PayingApi
   */
  public getInvoiceById(aId: string, iId: string, options?: AxiosRequestConfig) {
    return PayingApiFp(this.configuration)
      .getInvoiceById(aId, iId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the current relaunch configuration for invoice
   * @param {string} aId Account identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PayingApi
   */
  public getInvoiceRelaunchConf(aId: string, options?: AxiosRequestConfig) {
    return PayingApiFp(this.configuration)
      .getInvoiceRelaunchConf(aId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Returned invoices are ordered by created datetime desc.
   * @summary Get known invoices of the specified account
   * @param {string} aId
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {InvoiceStatus} [status] Filter invoices by appropriate status. If null, returns all invoices
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PayingApi
   */
  public getInvoices(aId: string, page?: number, pageSize?: number, status?: InvoiceStatus, options?: AxiosRequestConfig) {
    return PayingApiFp(this.configuration)
      .getInvoices(aId, page, pageSize, status, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get known products of the specified account
   * @param {string} id
   * @param {boolean} [unique] If description is null, this parameter is required.
   * @param {string} [description] Filter product by description
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PayingApi
   */
  public getProducts(id: string, unique?: boolean, description?: string, options?: AxiosRequestConfig) {
    return PayingApiFp(this.configuration)
      .getProducts(id, unique, description, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get relaunches of a specified invoice
   * @param {string} aId Account identifier
   * @param {string} iId Invoice identifier
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {string} [type] Filter relaunches by type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PayingApi
   */
  public getRelaunches(aId: string, iId: string, page?: number, pageSize?: number, type?: string, options?: AxiosRequestConfig) {
    return PayingApiFp(this.configuration)
      .getRelaunches(aId, iId, page, pageSize, type, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Can be filter by : * unique : show distinct transaction categories * userDefined : show transaction categories defined by the user * date intervals : give the count of transaction categories used by existing transactions  between two dates
   * @summary Get known transaction categories of an account
   * @param {string} aId Account identifier
   * @param {string} from
   * @param {string} to
   * @param {boolean} [userDefined]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PayingApi
   */
  public getTransactionCategories(aId: string, from: string, to: string, userDefined?: boolean, options?: AxiosRequestConfig) {
    return PayingApiFp(this.configuration)
      .getTransactionCategories(aId, from, to, userDefined, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get transactions of an account
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PayingApi
   */
  public getTransactions(id: string, options?: AxiosRequestConfig) {
    return PayingApiFp(this.configuration)
      .getTransactions(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the transactions summary of an account
   * @param {string} aId
   * @param {number} [year] Default value is current year
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PayingApi
   */
  public getTransactionsSummary(aId: string, year?: number, options?: AxiosRequestConfig) {
    return PayingApiFp(this.configuration)
      .getTransactionsSummary(aId, year, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Initiate payment processes to an account
   * @param {string} id
   * @param {Array<PaymentInitiation>} paymentInitiation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PayingApi
   */
  public initiatePayments(id: string, paymentInitiation: Array<PaymentInitiation>, options?: AxiosRequestConfig) {
    return PayingApiFp(this.configuration)
      .initiatePayments(id, paymentInitiation, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Relaunch an invoice
   * @param {string} aId Account identifier
   * @param {string} iId Invoice identifier
   * @param {CreateInvoiceRelaunch} [createInvoiceRelaunch]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PayingApi
   */
  public relaunchInvoice(aId: string, iId: string, createInvoiceRelaunch?: CreateInvoiceRelaunch, options?: AxiosRequestConfig) {
    return PayingApiFp(this.configuration)
      .relaunchInvoice(aId, iId, createInvoiceRelaunch, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * ProspectingApi - axios parameter creator
 * @export
 */
export const ProspectingApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get marketplaces for an account
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMarketplaces: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getMarketplaces', 'id', id);
      const localVarPath = `/accounts/{id}/marketplaces`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProspectingApi - functional programming interface
 * @export
 */
export const ProspectingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ProspectingApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get marketplaces for an account
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMarketplaces(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Marketplace>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMarketplaces(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * ProspectingApi - factory interface
 * @export
 */
export const ProspectingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ProspectingApiFp(configuration);
  return {
    /**
     *
     * @summary Get marketplaces for an account
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMarketplaces(id: string, options?: any): AxiosPromise<Array<Marketplace>> {
      return localVarFp.getMarketplaces(id, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * ProspectingApi - object-oriented interface
 * @export
 * @class ProspectingApi
 * @extends {BaseAPI}
 */
export class ProspectingApi extends BaseAPI {
  /**
   *
   * @summary Get marketplaces for an account
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProspectingApi
   */
  public getMarketplaces(id: string, options?: AxiosRequestConfig) {
    return ProspectingApiFp(this.configuration)
      .getMarketplaces(id, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * SecurityApi - axios parameter creator
 * @export
 */
export const SecurityApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create a new access token and corresponding refresh token
     * @param {CreateToken} createToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createToken: async (createToken: CreateToken, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createToken' is not null or undefined
      assertParamExists('createToken', 'createToken', createToken);
      const localVarPath = `/token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(createToken, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Initiate an authentication process
     * @param {AuthInitiation} authInitiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initiateAuth: async (authInitiation: AuthInitiation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'authInitiation' is not null or undefined
      assertParamExists('initiateAuth', 'authInitiation', authInitiation);
      const localVarPath = `/authInitiation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(authInitiation, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Check server health
     * @summary pong
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ping`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Who Am I? Tells you who you are
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    whoami: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/whoami`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SecurityApi - functional programming interface
 * @export
 */
export const SecurityApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SecurityApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create a new access token and corresponding refresh token
     * @param {CreateToken} createToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createToken(createToken: CreateToken, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createToken(createToken, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Initiate an authentication process
     * @param {AuthInitiation} authInitiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async initiateAuth(
      authInitiation: AuthInitiation,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Redirection1>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.initiateAuth(authInitiation, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Check server health
     * @summary pong
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ping(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Who Am I? Tells you who you are
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async whoami(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Whoami>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.whoami(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * SecurityApi - factory interface
 * @export
 */
export const SecurityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = SecurityApiFp(configuration);
  return {
    /**
     *
     * @summary Create a new access token and corresponding refresh token
     * @param {CreateToken} createToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createToken(createToken: CreateToken, options?: any): AxiosPromise<Token> {
      return localVarFp.createToken(createToken, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Initiate an authentication process
     * @param {AuthInitiation} authInitiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initiateAuth(authInitiation: AuthInitiation, options?: any): AxiosPromise<Redirection1> {
      return localVarFp.initiateAuth(authInitiation, options).then(request => request(axios, basePath));
    },
    /**
     * Check server health
     * @summary pong
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping(options?: any): AxiosPromise<string> {
      return localVarFp.ping(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Who Am I? Tells you who you are
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    whoami(options?: any): AxiosPromise<Whoami> {
      return localVarFp.whoami(options).then(request => request(axios, basePath));
    },
  };
};

/**
 * SecurityApi - object-oriented interface
 * @export
 * @class SecurityApi
 * @extends {BaseAPI}
 */
export class SecurityApi extends BaseAPI {
  /**
   *
   * @summary Create a new access token and corresponding refresh token
   * @param {CreateToken} createToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityApi
   */
  public createToken(createToken: CreateToken, options?: AxiosRequestConfig) {
    return SecurityApiFp(this.configuration)
      .createToken(createToken, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Initiate an authentication process
   * @param {AuthInitiation} authInitiation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityApi
   */
  public initiateAuth(authInitiation: AuthInitiation, options?: AxiosRequestConfig) {
    return SecurityApiFp(this.configuration)
      .initiateAuth(authInitiation, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Check server health
   * @summary pong
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityApi
   */
  public ping(options?: AxiosRequestConfig) {
    return SecurityApiFp(this.configuration)
      .ping(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Who Am I? Tells you who you are
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityApi
   */
  public whoami(options?: AxiosRequestConfig) {
    return SecurityApiFp(this.configuration)
      .whoami(options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * UserAccountsApi - axios parameter creator
 * @export
 */
export const UserAccountsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Approve a user legal file
     * @param {string} uId
     * @param {string} lId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    approveLegalFile: async (uId: string, lId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'uId' is not null or undefined
      assertParamExists('approveLegalFile', 'uId', uId);
      // verify required parameter 'lId' is not null or undefined
      assertParamExists('approveLegalFile', 'lId', lId);
      const localVarPath = `/users/{uId}/legalFiles/{lId}`
        .replace(`{${'uId'}}`, encodeURIComponent(String(uId)))
        .replace(`{${'lId'}}`, encodeURIComponent(String(lId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get accountHolders of an account
     * @param {string} userId
     * @param {string} accountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountHolders: async (userId: string, accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('getAccountHolders', 'userId', userId);
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getAccountHolders', 'accountId', accountId);
      const localVarPath = `/users/{userId}/accounts/{accountId}/accountHolders`
        .replace(`{${'userId'}}`, encodeURIComponent(String(userId)))
        .replace(`{${'accountId'}}`, encodeURIComponent(String(accountId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get accounts of a user
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountsByUserId: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getAccountsByUserId', 'id', id);
      const localVarPath = `/users/{id}/accounts`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all business activities pre-inserted by admin.
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBusinessActivities: async (page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/businessActivities`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get legal files of a user
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLegalFiles: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getLegalFiles', 'id', id);
      const localVarPath = `/users/{id}/legalFiles`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a user
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getUserById', 'id', id);
      const localVarPath = `/users/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update business activities of an account holder
     * @param {string} userId
     * @param {string} accountId
     * @param {string} ahId
     * @param {CompanyBusinessActivity} [companyBusinessActivity]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateBusinessActivities: async (
      userId: string,
      accountId: string,
      ahId: string,
      companyBusinessActivity?: CompanyBusinessActivity,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('updateBusinessActivities', 'userId', userId);
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('updateBusinessActivities', 'accountId', accountId);
      // verify required parameter 'ahId' is not null or undefined
      assertParamExists('updateBusinessActivities', 'ahId', ahId);
      const localVarPath = `/users/{userId}/accounts/{accountId}/accountHolders/{ahId}/businessActivities`
        .replace(`{${'userId'}}`, encodeURIComponent(String(userId)))
        .replace(`{${'accountId'}}`, encodeURIComponent(String(accountId)))
        .replace(`{${'ahId'}}`, encodeURIComponent(String(ahId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(companyBusinessActivity, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update company info of an account holder
     * @param {string} userId
     * @param {string} accountId
     * @param {string} ahId
     * @param {CompanyInfo} [companyInfo]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCompanyInfo: async (
      userId: string,
      accountId: string,
      ahId: string,
      companyInfo?: CompanyInfo,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('updateCompanyInfo', 'userId', userId);
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('updateCompanyInfo', 'accountId', accountId);
      // verify required parameter 'ahId' is not null or undefined
      assertParamExists('updateCompanyInfo', 'ahId', ahId);
      const localVarPath = `/users/{userId}/accounts/{accountId}/accountHolders/{ahId}/companyInfo`
        .replace(`{${'userId'}}`, encodeURIComponent(String(userId)))
        .replace(`{${'accountId'}}`, encodeURIComponent(String(accountId)))
        .replace(`{${'ahId'}}`, encodeURIComponent(String(ahId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(companyInfo, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserAccountsApi - functional programming interface
 * @export
 */
export const UserAccountsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserAccountsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Approve a user legal file
     * @param {string} uId
     * @param {string} lId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async approveLegalFile(
      uId: string,
      lId: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LegalFile>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.approveLegalFile(uId, lId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get accountHolders of an account
     * @param {string} userId
     * @param {string} accountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAccountHolders(
      userId: string,
      accountId: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountHolder>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountHolders(userId, accountId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get accounts of a user
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAccountsByUserId(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountsByUserId(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get all business activities pre-inserted by admin.
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBusinessActivities(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BusinessActivity>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessActivities(page, pageSize, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get legal files of a user
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLegalFiles(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LegalFile>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLegalFiles(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get a user
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserById(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Update business activities of an account holder
     * @param {string} userId
     * @param {string} accountId
     * @param {string} ahId
     * @param {CompanyBusinessActivity} [companyBusinessActivity]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateBusinessActivities(
      userId: string,
      accountId: string,
      ahId: string,
      companyBusinessActivity?: CompanyBusinessActivity,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountHolder>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateBusinessActivities(userId, accountId, ahId, companyBusinessActivity, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Update company info of an account holder
     * @param {string} userId
     * @param {string} accountId
     * @param {string} ahId
     * @param {CompanyInfo} [companyInfo]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateCompanyInfo(
      userId: string,
      accountId: string,
      ahId: string,
      companyInfo?: CompanyInfo,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountHolder>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateCompanyInfo(userId, accountId, ahId, companyInfo, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * UserAccountsApi - factory interface
 * @export
 */
export const UserAccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = UserAccountsApiFp(configuration);
  return {
    /**
     *
     * @summary Approve a user legal file
     * @param {string} uId
     * @param {string} lId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    approveLegalFile(uId: string, lId: string, options?: any): AxiosPromise<LegalFile> {
      return localVarFp.approveLegalFile(uId, lId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get accountHolders of an account
     * @param {string} userId
     * @param {string} accountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountHolders(userId: string, accountId: string, options?: any): AxiosPromise<Array<AccountHolder>> {
      return localVarFp.getAccountHolders(userId, accountId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get accounts of a user
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountsByUserId(id: string, options?: any): AxiosPromise<Array<Account>> {
      return localVarFp.getAccountsByUserId(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get all business activities pre-inserted by admin.
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBusinessActivities(page?: number, pageSize?: number, options?: any): AxiosPromise<Array<BusinessActivity>> {
      return localVarFp.getBusinessActivities(page, pageSize, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get legal files of a user
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLegalFiles(id: string, options?: any): AxiosPromise<Array<LegalFile>> {
      return localVarFp.getLegalFiles(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get a user
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserById(id: string, options?: any): AxiosPromise<User> {
      return localVarFp.getUserById(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Update business activities of an account holder
     * @param {string} userId
     * @param {string} accountId
     * @param {string} ahId
     * @param {CompanyBusinessActivity} [companyBusinessActivity]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateBusinessActivities(
      userId: string,
      accountId: string,
      ahId: string,
      companyBusinessActivity?: CompanyBusinessActivity,
      options?: any
    ): AxiosPromise<AccountHolder> {
      return localVarFp.updateBusinessActivities(userId, accountId, ahId, companyBusinessActivity, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Update company info of an account holder
     * @param {string} userId
     * @param {string} accountId
     * @param {string} ahId
     * @param {CompanyInfo} [companyInfo]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCompanyInfo(userId: string, accountId: string, ahId: string, companyInfo?: CompanyInfo, options?: any): AxiosPromise<AccountHolder> {
      return localVarFp.updateCompanyInfo(userId, accountId, ahId, companyInfo, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * UserAccountsApi - object-oriented interface
 * @export
 * @class UserAccountsApi
 * @extends {BaseAPI}
 */
export class UserAccountsApi extends BaseAPI {
  /**
   *
   * @summary Approve a user legal file
   * @param {string} uId
   * @param {string} lId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserAccountsApi
   */
  public approveLegalFile(uId: string, lId: string, options?: AxiosRequestConfig) {
    return UserAccountsApiFp(this.configuration)
      .approveLegalFile(uId, lId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get accountHolders of an account
   * @param {string} userId
   * @param {string} accountId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserAccountsApi
   */
  public getAccountHolders(userId: string, accountId: string, options?: AxiosRequestConfig) {
    return UserAccountsApiFp(this.configuration)
      .getAccountHolders(userId, accountId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get accounts of a user
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserAccountsApi
   */
  public getAccountsByUserId(id: string, options?: AxiosRequestConfig) {
    return UserAccountsApiFp(this.configuration)
      .getAccountsByUserId(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get all business activities pre-inserted by admin.
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserAccountsApi
   */
  public getBusinessActivities(page?: number, pageSize?: number, options?: AxiosRequestConfig) {
    return UserAccountsApiFp(this.configuration)
      .getBusinessActivities(page, pageSize, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get legal files of a user
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserAccountsApi
   */
  public getLegalFiles(id: string, options?: AxiosRequestConfig) {
    return UserAccountsApiFp(this.configuration)
      .getLegalFiles(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a user
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserAccountsApi
   */
  public getUserById(id: string, options?: AxiosRequestConfig) {
    return UserAccountsApiFp(this.configuration)
      .getUserById(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update business activities of an account holder
   * @param {string} userId
   * @param {string} accountId
   * @param {string} ahId
   * @param {CompanyBusinessActivity} [companyBusinessActivity]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserAccountsApi
   */
  public updateBusinessActivities(
    userId: string,
    accountId: string,
    ahId: string,
    companyBusinessActivity?: CompanyBusinessActivity,
    options?: AxiosRequestConfig
  ) {
    return UserAccountsApiFp(this.configuration)
      .updateBusinessActivities(userId, accountId, ahId, companyBusinessActivity, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update company info of an account holder
   * @param {string} userId
   * @param {string} accountId
   * @param {string} ahId
   * @param {CompanyInfo} [companyInfo]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserAccountsApi
   */
  public updateCompanyInfo(userId: string, accountId: string, ahId: string, companyInfo?: CompanyInfo, options?: AxiosRequestConfig) {
    return UserAccountsApiFp(this.configuration)
      .updateCompanyInfo(userId, accountId, ahId, companyInfo, options)
      .then(request => request(this.axios, this.basePath));
  }
}
